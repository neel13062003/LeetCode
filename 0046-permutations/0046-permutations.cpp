class Solution {
public:
    
    void display(vector<int>&nums,int n,vector<vector<int>>&ans){
        vector<int>temp;
        for(int i=0;i<n;i++){
            temp.push_back(nums[i]);
        }
        ans.push_back(temp);
    }
    
    void findPermutations(vector<int>&nums,int n,vector<vector<int>>&ans){
        sort(nums.begin(),nums.end());
        do{
            display(nums,n,ans);
        }while (next_permutation(nums.begin(),nums.end()));
    }
    
    
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>ans;
        int n=nums.size();
        findPermutations(nums,n,ans);
        return ans;
    }
};

/*The time complexity of the given code is O(n * n!), where n is the number of elements in the input vector nums.

The reason for this is that the findPermutations() function generates all the permutations of the nums vector using the next_permutation() function. The number of permutations of n elements is n!, so generating all the permutations takes O(n!) time.

For each permutation generated by next_permutation(), the display() function creates a copy of the vector and pushes it to the ans vector. Creating a copy of the vector takes O(n) time, so this step is performed n! times, giving a total time complexity of O(n * n!).

Therefore, the overall time complexity of the permute() function is O(n * n!). Note that this is a very high time complexity and the code may not scale well for large input sizes. There are faster algorithms for generating permutations, such as the recursive backtracking algorithm or the iterative algorithm based on Johnson-Trotter's algorithm.*/